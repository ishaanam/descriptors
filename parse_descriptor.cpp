#include <stdexcept>

#include "tokenizer.h"
#include "descriptor.h"

/*
    Converts a vector of tokens generated by Tokenizer() into an object
    of the Descriptor class.
*/

ScriptType string_to_script_type(const std::string& script_string)
{
    auto it = script_types.find(script_string);
    if (it == script_types.end()) return ScriptType::UNKNOWN_SCRIPT;
    return it->second;
}

void parse_function(const ScriptType& func_type, const std::vector<Token>& tokens, ScriptExpression& script_expr, const int function_index)
{
    switch (func_type)
    {
        case ScriptType::MULTI:
        case ScriptType::SORTEDMULTI: 
        case ScriptType::SH:
        case ScriptType::WSH: {
            throw std::runtime_error("This parser doesn't currently support some of the script expressions included in this descriptor");
        }
        case ScriptType::PK:
        case ScriptType::PKH:
        case ScriptType::WPKH: {
            // assert that the next token is a KEY
            const Token& next_token = tokens[function_index + 1];
            assert (next_token.type == TokenType::KEY);
            // set the key now
            KeyExpression key_expr;
            key_expr.parse_raw_key_expr(next_token.raw_token);
            key_expr.set_key_type();
            script_expr.script_args.push_back(static_cast<ScriptArg>(key_expr));
            // assert that the next thing is an END_FUNC token
            assert (tokens[function_index + 2].type == TokenType::END_FUNC);
            break;
        }
        default:
            break;
    }
}

Descriptor tokens_to_descriptor(const std::vector<Token>& tokens)
{
    Descriptor descriptor;
    ScriptExpression& script_expr = descriptor.script_expr;

    for (int i=0; i < tokens.size(); i++)
    {
        const Token& token = tokens[i];
        switch (token.type)
        {
            case (TokenType::FUNCTION): {
                script_expr.script_function =  string_to_script_type(token.raw_token);
                parse_function(script_expr.script_function, tokens, script_expr, i);
                if (std::holds_alternative<ScriptExpression>(script_expr.script_args[0]))
                {
                    script_expr = std::get<ScriptExpression>(script_expr.script_args[0]);
                }
                break;
            }
            case (TokenType::CHECKSUM): {
                descriptor.checksum = token.raw_token;
                // assert that this is the last token
                assert (tokens[i+1].raw_token == "");
                break;
            }
            case (TokenType::KEY):
            case (TokenType::END_FUNC):
            default:
                break;
        }
    }
    return descriptor;
}

Descriptor ss_to_descriptor(std::stringstream ss)
{
    const std::vector<Token> tokens = Tokenizer(ss);
    return tokens_to_descriptor(tokens);
}
